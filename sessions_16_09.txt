

Interviews : Takeaways .
reference : Narasimha Karumanchi , websites .

Tasks: go through every single function you can lay your eyes on.


make a folder ...code almost every single function from official docs.



Array :


-->declarations

-->manipulations  **

-->return statements


4- 1= 3


n - j= j

B[i]=A[n-i-1]



basic arithmetic operators :

+ -->increment..move forward
-   moving back
*   moving forward in leaps and bounds
/  moving backward in leaps and bounds

%  -> rotation  



0%3 = 0
1%3 = 1
2%3 = 2
3&3 = 0
      1
      2




0 1 2 0 1 2 0 1 2


3 4 5 0 1 2 



3 4 5 0 1 2 3 4 5 



Algortithm O(npow3)

for i : 0->n
	for j:i->n
		ans =INT_MIN
		for k:i->j(included)
			sum+=A[k]           sum=sum+A[k]
		ans=max(ans,sum)


Algorithm O(npow2)

for i: 0->n
	for : i->n
		sum+=A[j]
	ans=max(ans,sum)



anytime you want to optimize your code : 

-->more variables
-->more comparisons



......3 7 =10
......-3 7 
Algorithm O(n)

for i: 0->n
	sum=max(A[i],A[i]+sum)    // v difficult to think of
	ans =max(best,ans)

return ans



Tasks:
Arrays,lists,Al --functions and code


 Interview bit Array Math:

Min Steps in Infinite Grid 
Pascal Triangle 
Anti diagonals  

all 30 mins




SORTING :

-->

Q.................

-->sort --> c++ sort(A.begin(),A.end()) 

---------
if u remember the logic behind sort


---> get you more comfy with how to check where you are values are moving

** take the algo down in your notes...refer the algo or bullets points and reconstruct the code
-->bubble
-->selection
-->insertion   -->can you code making the inside loop a for loop
-->merge       -->recursion ---> how much is it troubling you
-->quick       -->pay attention to the partition
-->heap



sort --> O(n logn)   --> this automatically makes your whole code nlogn complex.



try to learn a sort function with O(n) complexity.


for : i : 1->n
	ans+=max(abs(A[i]-A[i-1]),abs(B[i]-B[i-1]))

return ans


i: 1-> NumOfRows
j: 1->i
R[i][j] = R[i-1][j-1]+R[i-1][j]


1*1 -->1
2*2 -->3
3*3 -->5

i+j =K = row number in final op

2N-1 = numof rows
res array size =2n-1

for i:0->n
	j:0->n

	 in R[i+j] insert A[i][j]

5 codes of sorting in arrays

Kth Row of Pascal's Triangle
set matrix 0 *
first missing integer *


flag variables 


-->flag -- indicator 

flag - 0/1 on/off toggle button


bool dont declare integer and then just use 0 and 1

1: 4 -->O(1)

array of flags : n: 4n   --> 500 unit of memory 


 without if : you cant toggle

states : interchangable and not mutually exclusive

0 0 0
0 0 0
0 0 0


two pointer approach


template :

Array, String 

 v1.................. v2



array , sorted 

n1+n2 = X

brute force : O(n pow 2)

for : i:0->n
	for : j : i+1->n

	if(A[i]+A[j]==X) done.

O(n) two pointer approach:

standard ( most frequently useful approach)
v1 = 0
v2 = n-1


while (standard condition v1<v2)
{
	if(A[v1]+A[v2]==X) done.

	else if (A[v1]+A[v2]>X) decrement v2.

	else increment v1
}


v1----------------->
				   <------------------------v2

counter variable :



PAYPALISHIRING


P   A  L
A   P  I  H
Y      S 

Repeat and Missing Number Array
N/3 Repeat Number
flip
max absolute difference



STRINGS :

-->official docs and pickup functions

-->apart from standard string functions try and implement general functions as well.

Things to remember :

setting, resetting strings  --every loop your string is being changed

cpp - stringstream
java -Scanner
python- ### google stringstream module for python


remove concept of interconversions

int->strings
string->int

the best way to interchange char and ascii value


-'0'

Interview point of view :

advantage c++ over java and python


11111111111111     inside if      22222222222222222222222222

count =9 and 1              count =1        count =15 and 2




PALINDROMES

-->Dynamic programming
	-->arrays
	-->strings -->4 models -->2 heavily depend on palindromes

-->common ones :
	1.reverse and compare
	2.two pointer approach
		i ---> mid <-------j
	3.for i 0->n/2
		A[i] and A[n-i-1]


3.
  string s="malaalamy"
  for : i:0->n/2  (n/2 or n/2 -1 or +1) (revise odd/even number properties)
  		if(A[i]!=A[n-i-1])
  			return false

  		return true;


uncommon approaches;

1. using stack

		malayalam
	-->push half the elements in stack 

	-->pop them one by one and check with the left over string

	time:O(n) space:O(n)

2. using recursion

	func check(string s)
		int l =s.len()

		//base case
		if(l==0|| l==1)
			return true

		if(s[0]==s[l-1])
			return check(s.substr(1,l-1))

		return false


recursion + control flow


string tricks : code all 5

c c c c c c c c c c c c c ...............................
o c o c o c o c o c o c o ...............................
o c c c o o.........................
      o

n - all monkeys with number which is a factor of n touch it.

9
1*9 1,3,9.
3*3

8
1,2,4,8.

4
1 2 4

16
1 2 4 8 16


MATH :

prime numbers  : factorization

base number system:

binary base  : hamming distance

2 types:

1
if mult 3 then fizz
elif mult 5 then buzz
elif mult 15 fizzbuzz


2
if mult 15 fizzbuzz
elif mult 3 then fizz
elif mult 5 then buzz

Distribute in Circle!
Is Rectangle?
Excel Column Number	
Excel Column Title
Greatest Common Divisor ( both iterative and recursive)


BIT MANIPULATION :

14 = 1 1 1 0

32 bit number

0000 0000 0000 1110


bitwise operators :

& 1&1 =1  

| 0|0 =0

^ diff bit then 1       1^0 or 0^1  

~ complement

<<  


int A=29 x=2
............................1 1 1               0 1
A>>x  = ? 7
>>

A>>x   div with x no of times
A<<x   multiply with 2 x no of times

bit tricks file :


x & (x-1) will clear the lowest set bit of x

8 & 7 =?

1 0 0 0                  0 1 1 1
 
0 1 1 1                  0 1 1 0 

-------------------------------------------
0 0 0 0                  0 1 1 0 ---> 0 1 0 0--->0 0 0 0 



x & ~(x-1) extracts the lowest set bit of x (all others are clear). Pretty patterns when applied to a linear sequence.

8 & ~(7) = ~(0111) = 1 0 0 0

1 0 0 0              0 1 1 1               

1 0 0 0              1 0 0 1
--------- -------------------------
1 0 0 0              0 0 0 1


00000000000000000000000001000000000000000000



x & (x + (1 << n)) = x, with the run of set bits (possibly length 0) starting at bit n cleared.
x & ~(x + (1 << n)) = the run of set bits (possibly length 0) in x, starting at bit n.
x | (x + 1) = x with the lowest cleared bit set.
x | ~(x + 1) = extracts the lowest cleared bit of x (all others are set).
x | (x - (1 << n)) = x, with the run of cleared bits (possibly length 0) starting at bit n set.
x | ~(x - (1 << n)) = the lowest run of cleared bits (possibly length 0) in x, starting at bit n are the only clear bits.


number of 1 bits

1.
  mod and divide 

2. 
  conversion : into string   // bitset

3. bit tricks
	counter=0;
	while(x!=0)
		x=x&(x-1)
		counter++

	return counter

4.
	32 bits 

	counter=0
	for(int i=0;i<32;i++)
	{
		if(A&(1<<i))
			counter++
	}
	return 


	xxxxxxxxxxxxxxxxxxxxxxxxxxxx
	1			

Trailing zeroes :

1. count and break

	count=0

	while A:
		if A&1 :
			break
		else
			count++

		A=A>>1
	return count


2. 32 bits
	for(..............)
		if(A&(1<<i)):
			return i


min XOR value

1. brute force
	all possible pairs
		minn=min((xor_pair_value),(minn))

	return min


0111 1000  4

1000 1001  1
2.
	sort
	for(............<n-1)
		minn=min((xor_A[i]_A[i+1]),(minn))
	return min


3.
	m=max(arr)
	r=arr[0]
	for i in arr:
   		if r^arr[i+1]<m:
      		r=r^arr[i+1]
      		m=arr[i]^arr[i+1]


complete bit manipulation as much as possible 


BINARY SEARCH :

int binaryS(int A[],int l, int r, int key)
	
	while(l<=r){                                                            
		int mid =l+(r-l)/2                                                


		if(A[mid]==key) **********************
			return mid

		if(A[mid]<key)  **********************
			l= mid+1

		else
			r = mid-1
	}

	return -1


---------------l-----------------r

int binaryS(int A[],int l, int r, int key)
	
	if(r>=l)
		int mid= l+(r-l)/2

	if(A[mid]==key)
		return mid

	if(A[mid]>key)
		return binaryS(A,l,mid-1,key)

	return binaryS(A,mid+1,r,key)

	return -1


visualise
setting limits


1->A integers

long l =1 

long r =A    A/2

long mid = l+(r-l)/2    start+end /2

if( mid*mid <=A && (mid+1)* (mid+1) >A)   ( not always possible)
	return mid

else if(mid*mid<A)
	l=mid+1

else
	r=mid-1


mid <A/mid

2+3 =5


11 -> 3


code binary search in iterative and recursive

sqaure root of integer

simple binary search and search answer sections


TWO POINTERS :

def pairSum(int A[], int N, int T)
{
	sort(A)
	int i =0
	int j = N-1

	while(i<j)
	{
		if(A[i]+A[j]==T)   //cond need to be solved
			return true

		//
		else if(A[i]+A[j]<T)
			i++;


		//
		else
			j--;

	}


}

A+B=X
B+A=X

A-B=X
B-A=X